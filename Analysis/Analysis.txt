محاسبه پیچیدگی زمانی و فضایی الگوریتم

۱. پیچیدگی زمانی
پیچیدگی زمانی الگوریتم به چند مرحله وابسته است:  
1. ساخت ایندکس معکوس (`addDocument`)
   - برای هر سند:
     - پردازش تمام کلمات سند: (O(W))، که (W) تعداد کلمات کل سند است.
     - درج هر کلمه در `Map`: (O(1)) برای هر کلمه (به دلیل استفاده از جدول هش).  
     - در مجموع:(O(N times W))، که (N) تعداد اسناد و (W) میانگین تعداد کلمات هر سند است.

2. پرس‌وجو و جستجو (`processQuery`)
   - تحلیل کوئری (`parseQuery`): این مرحله تنها یک بار روی کوئری انجام می‌شود و زمان آن (O(Q)) است، که (Q) طول کوئری است.
   - دریافت اسناد مربوط به کلمات:
     - برای هر کلمه در کوئری:
       - بازیابی از `Map`: (O(1)).
       - در بدترین حالت، باید این کار برای تمام کلمات کوئری انجام شود: (O(K))، که (K) تعداد کلمات در کوئری است.
   - محاسبه اشتراک، اتحاد و تفریق مجموعه‌ها:
     - عملیات روی مجموعه‌ها (مانند `set_intersection`) دارای پیچیدگی (O(M)) است، که (M) تعداد اسناد مرتبط با هر کلمه است.
     - اگر کوئری شامل (K) کلمه باشد و هر کلمه حداکثر با (M) سند مرتبط باشد، زمان کل برای پردازش کوئری: (O(K times M)).

بدترین حالت کلی:  
- ساخت ایندکس: (O(N times W)).  
- جستجو: (O(Q + K times M)).  


۲. پیچیدگی فضایی
- ایندکس معکوس (`Map`):
  - برای هر کلمه، لیستی از اسناد نگهداری می‌شود. در بدترین حالت:
    - تعداد کلمات: (V) (اندازه دایره‌المعارف کلمات).
    - تعداد اسناد مرتبط با هر کلمه: حداکثر (N).
    - فضای کل: (O(V times N)).

- حافظه موقت در جستجو:
  - برای هر عملیات مجموعه (مانند اشتراک)، نیاز به نگهداری موقت مجموعه‌ها داریم.
  - در بدترین حالت: (O(M)) برای هر مجموعه.
  - فضای کل موقت برای جستجو: (O(K times M) ).

بدترین حالت کلی:  
- فضای ایندکس: (O(V times N)).  
- فضای موقت جستجو: (O(K times M)).  


بهینه‌سازی‌ها

۱. بهینه‌سازی زمانی
1. کاهش اندازه ایندکس:
   - حذف کلمات توقف (`stop words`) و استفاده از ریشه‌یابی (`stemming`) یا لماتیزاسیون (`lemmatization`) برای کاهش تعداد کلیدها.

2. استفاده از لیست‌های مرتب:
   - نگهداری لیست اسناد به صورت مرتب‌شده برای هر کلمه:
     - بهینه‌سازی عملیات اشتراک و اتحاد به (O(min(M1, M2)))، که (M1) و (M2) اندازه دو مجموعه هستند.

3. فیلتر بلوم (Bloom Filter):
   - قبل از جستجوی کلمات در ایندکس، از فیلتر بلوم استفاده کنید تا هزینه جستجوی کلمات ناموجود را کاهش دهید.


۲. بهینه‌سازی فضایی
1. فشرده‌سازی ایندکس:
   - استفاده از الگوریتم‌هایی مانند **Gap Encoding** یا **Delta Encoding** برای کاهش فضای مورد نیاز برای نگهداری لیست اسناد.

2. ایندکس‌های تفکیکی:
   - ایندکس‌گذاری بر اساس توزیع اسناد (مثلاً بر اساس دایرکتوری‌ها یا موضوعات) برای کاهش فضای مورد نیاز و بهبود جستجو.

3. تخصیص پویا برای اسناد:
   - استفاده از داده‌ساختارهایی مانند `unordered_map` به جای جدول هش ثابت برای بهینه‌سازی تخصیص حافظه.


ساختارهای مورد استفاده در موتورهای جستجو واقعی

1. ایندکس معکوس توزیع‌شده:
   - موتورهای جستجو مانند Google از ایندکس معکوس در مقیاس بسیار بزرگ استفاده می‌کنند که بین چندین سرور توزیع شده است.

2. نمایه‌سازی مبتنی بر ستون:
   - استفاده از پایگاه داده‌های ستون‌محور (مانند BigTable) برای ذخیره‌سازی ایندکس‌ها.

3. الگوریتم‌های بهینه‌سازی جستجو:
   - الگوریتم‌های جستجوی سریع مانند **skip list** یا **binary search** روی لیست‌های مرتب.

4. پیش‌پردازش پرس‌وجو:
   - استفاده از تحلیل معنایی برای اصلاح کوئری کاربر و تولید پرس‌وجوهای بهینه.

5. استفاده از حافظه پنهان (Caching):
   - ذخیره نتایج جستجوهای پرکاربرد برای پاسخ‌دهی سریع‌تر.


پیشنهادات برای پروژه شما

1. کاهش حافظه ایندکس:
   - از روش‌های فشرده‌سازی (مانند Gap Encoding) برای ذخیره لیست اسناد استفاده کنید.

2. بهینه‌سازی عملیات مجموعه:
   - اگر لیست اسناد مرتب است، از روش‌هایی مانند **merge-sort** برای محاسبه اشتراک استفاده کنید.

3. کاهش هزینه جستجو:
   - از ساختارهایی مانند **hash set** برای سرعت بیشتر در جستجو و عملیات مجموعه استفاده کنید.
